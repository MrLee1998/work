# 怎么解决继承的诸多问题？
  面向组合的设计方式，先设计一系列零件， 然后将这些零件进行拼装，来形成不同的实例或者类

# 前端性能优化
  缓存是性能优化非常重要的一点， 浏览器的缓存机制
  - 强缓存
  - 协商缓存
  - 缓存位置
  1. 强缓存
    浏览器的缓存策略分为两种情况， 一种是需要发送http请求的， 一种是不需要的。
    首先检查的是强缓存， 这个阶段是不需要发送http请求
    如何检查？
    通过相应的字段检查， 字段又分为哪些呢？
    Http1.0时期使用的是Expires， 而Http1.1使用的是Cache-Control。都存在于服务端返回的响应头
    Expires即过期时间， 在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求 服务器的时间和浏览器的时间可能并不一致，那服务器返回的事件就可能不准确，因此这种方法再Http/1.1版本中被抛弃
    Expires 和 Cache-Control的区别？
    它和Expires本质的不同在于它并没有采用具体的过期时间点这个方式，而是采用过期时长来控制缓存，对应的字段是max-age。
    当Expires和Cache-Control同时存在的时候，Cache-Control会优先考虑。
    当资源缓存事件超时了， 也就是强缓存失效了， 接下来就到了第二层屏障，协商缓存
  2. 协商缓存
    强缓存失效， 浏览器在请求头携带的相应的 缓存tag 来向服务器发出请求， 由服务器根据这个tag， 来决定是否使用缓存， 这就是协商缓存。
    缓存tag分为两种： Last-Modified 和 Etag， 两者各有优缺点， 跟强缓存的两个tag不一样
    - Last-Modified
      最后修改时间。在浏览器第一次给服务器发送请求后， 服务器会在响应头在上这个字段。
      浏览器接收后，再次发送请求， 会在请求头中携带If-Modified—Since字段， 这个字段的值也就是服务器传来的最后修改时间
      服务器拿到请求头里面的If-Modified-Since的字段后， 会和服务器该资源的最后修改时间 对比：
      - 请求头的值小于这个最后修改时间， 更新资源， 返回新的资源， 跟常规的http请求一样
      - 返回304，告诉浏览器直接使用缓存
    - Etag
      Etag 是服务器根据当前文件的内容， 给文件生成的唯一标识， 只要里面的内容有改动， 这个之就会变。服务器通过响应头把这个值给浏览器
      浏览器接收到Etag的值， 会在下次请求时， 将这个值作为 If-Node-Match这个字段的内容， 并放到请求头中，发送给服务端。
      服务器拿到If-Node-Match后， 会跟服务器上该资源的Etag进行比较
      - 两者不一样， 更新资源， 返回新资源， 跟常规的http请求一样
      - 返回304， 告诉浏览器直接使用缓存
    两者区别
      精度上Etag优于Last-Modified
      性能上Last-Modified优于Etag
    两种方式都支持， 服务器优先选择Etag

  3. 缓存位置
    浏览器的缓存位置一共有四种， 按优先级重高到低排列：
      - Service Worker
      - Memory Cache  内存缓存， 效率最高， 但存活时间短
      - Disk Cache    磁盘缓存  效率低， 但内存容量大
      - Push Cache    推送缓存  Http/2.0

  总结： 
    浏览器的缓存机制
    首先通过Cache-Control 验证强缓存是否可用
      如果可以， 直接使用从缓存中获取数据
      否则进入协商缓存， 即发送http请求， 通过请求头里的If-Modified-Since 或 If-Once-Match这些请求字段检查资源是否更新
        若更新， 更新后返回新的资源和200状态码
        否者， 返回304， 告诉浏览器从缓存中获取资源


# 浏览器的本地存储有哪些？ 各自的优劣如何?
  浏览器的本地存储主要分为Cookie， WebStorage和IndexDB， 其中webStorage又分为localStorage和sessionStorage
  - Cookie
      Cookie最开始被设计出来并不是来做本地存储的， 而是弥补Http在状态管理上的不足
      Http是一个无状态的协议， 客户端向服务端发出请求， 服务器返回响应，但是当下一次发请求如何让客户端知道时谁呢？
      这种背景下产生了Cookie
      Cookie的本质就是浏览器里面存储的一个很小的文本文件， 内部以键值对的形式来存储。 向同一个域名下发送请求， 都会携带相同的Cookie， 服务器拿到Cookie进行解析，便能拿到客户端的的状态
      Cookie的作用很好理解， 就是用来作状态存储的
      缺陷：
        容量小： 4kb
        性能缺陷：Cookie一直跟随着域名发送，不管需不需要，都会携带者Cookie， 造成浪费。
        安全问题：Cookie是纯文本的形式存在，很容易被非法用户截获，进行篡改。
  - localStorage
    针对同一个域名， 即再同一个域名下， 会存储相同的一段localStorage
      容量： 5M
      只存在客户端， 默认不参与服务端通信， 不会被携带
      持久性存储
  - sessionStorage
    刷新不会清除， 关闭当前页面才会清除
  - indexDB
    IndexDB是运行在浏览器中的非关系型数据库， 本质上是数据库， 理论上容量是没有上限的
    键值对存储。内部采用对象存放数据
    异步操作， 数据库的读写属于I/O操作， 浏览器对异步I/O提供了支持
    受同源策略影响， 无法跨域访问
  总结
    Cookie不适合存储
    localStorage 和sessionStorage默认不参与服务器的通信
    IndexDB为运行在浏览器上的非关系型数据库，为大型数据库的存储提供了接口

# 防抖 和 节流
  节流：
    核心思想： 如果在定时器的时间范围内再次触发， 则不给予理睬，等定时器完成， 才能启动下一次的定时器任务。
    这就好比公交车，10 分钟一趟，10 分钟内有多少人在公交站等我不管，10 分钟一到我就要发车走人！
  防抖：
    核心思想：每次时间触发则删除原来的定时器， 建立新的定时器。跟王者荣耀的回城效果一样， 你反复触发，那么只认最后一次
    ， 从最后一次触发开始计时
    
# http协议
  1. Http报文结构
    请求头和响应头格式：
      - 字段名不区分大小写
      - 字段名不允许出现空格， 不可以出现下划线_
      - 字段名后面必须紧跟着 :
    空行：
      很重要， 用来区分头部和实体
      问: 如果说在头部中间故意加一个空行会怎么样？
          那么空行后的内容全部被视为实体。
    实体：
      就是具体的数据， 也就是body部分。请求报文对应请求体， 响应报文对应响应体
  
  2. http的请求方法
    Http/1.1 规定以下请求方法， 都是大写
    - GET： 通常用来获取资源
    - HEAD：获取资源的元信息 元信息允许服务器提供所发送数据的信息
    - POST：提条数据， 及上传数据
    - PUT：修改数据
    - DELETE：删除数据 基本不用
    - CONNECT：建立隧道连接， 用于代理服务器
    - OPTIONS：列出可对资源实行的请求方法， 用来跨域
    - TRACE：追踪请求-响应的传输路径
    GET 和 POST有什么区别?
    缓存角度上， GET请求会被浏览器主动缓存下来， POST不会
    编码角度上：GET只能进行url编码， 只接收ASCII字符， POST没有限制
    参数角度上：GET的参数会拼接到url中，因此不安全， 而POST放在请求体中，适合传输隐秘信息
    幂等角度上： GET是幂等， POST不是
    TCP角度上： GET请求会把请求报文一次性发出去，而POST分为两个TCP数据包， 首先法header，
               服务器响应后， 再发出body部分
  3. 理解URL
    URL，全称（Uniform Resource Identifier）， 也就是统一资源标配符， 它的作用很简单， 就是区分互联网不同的资源
  4. http状态码
    RFC规定HTTP的状态码为三位数， 被分为五类：
    1xx： 表示目前是协议处理的中间状态， 还需要后续操作
    2xx：表示成功状态
    3xx：重定向状态， 资源位置发生变动，需要重新请求
    4xx：请求报文有误
    5xx：服务器端发生错误
  5. http 的特点
    特点概括：
      - 灵活可扩展
      - 可靠传输： http基于TCP/IP
      - 请求-应答：也就是一发一收， 有来有回
      - 无状态
    缺点概括：
      - 无状态
        在需要长连接的场景中， 需要保存大量的上下文信息， 以免传输大量重复的信息， 这个时候无状态就是缺点了
        相反， 一些应用仅仅是为了获取一些数据， 不需要保存连接上下文， 无状态反而减少了网络开销， 成了http的优点
      - 明文传输
      - 队头阻塞问题
  6. 定长和不定长的数据，http怎么传输
    定长包体：
      Content-Length设置包的长度
    不定长包体：
      Transfer-Encoding: chunked 分块传输数据
  7. http如何处理一个大文件传输？
    请求资源的一部分： 前提是服务器支持范围请求，要支持这个功能， 就必须加上这样一个请求头： Accept-Ranges: none
    来告知客户端这边是支持范围请求的
    - Range字段拆解