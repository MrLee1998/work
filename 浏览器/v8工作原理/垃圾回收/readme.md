# 垃圾回收

  1. 手动回收（例如：c/c++）

  2. 自动回收（例如：JavaScript， Java， python）


# 栈中的垃圾数据和堆中的垃圾数据的回收机制

栈中的垃圾数据
  JavaScript 引擎会通过向下移动ESP指针来销毁函数保存在栈当中的执行上下文

堆中的垃圾数据：


# 代际假说 和 分代收集

 - 代际假说： 
 
 1. 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问
 2. 不死的对象，会活得很久，例如：window、document、window下的全局对象


 通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到更好的效果。

 v8 把堆分为 ‘新生代’ 和 ‘老生代’ 两个区域
  新生代：存放的是生存时间短的对象， 1~8M的容量
  老生代：存放的是生存时间久的对象   容量较大

  副垃圾回收器，主要负责新生代的垃圾回收
  主垃圾回收器，主要负责老生代的垃圾回收

  # 垃圾回收器的工作流程
  无论什么类型的垃圾回收器，它们都有一套共同的执行流程
  1. 标记空间的“活动对象（还在使用的对象）” 和 “非活动对象（可以进行垃圾回收的对象）”
  2. 回收 “非活动对象” 所占据的内存。其实就是在标记完成之后，统一清理内存种所有被标记为可回收的对象
  3. 内存整理
    频繁回收对象后，内存中就存在大量不连续空间，我们把这些不连续的内存空间称为”内存碎片“
    当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就可能出现内存不足的情况。
    所以需要整理这些内存碎片

  # 副垃圾回收机制
  主要负责：新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说，这个区域虽然不大，但是垃圾回收还是比较频繁的。
  - Scanvenge算法
  把新生代空间对半划分为两个区域，一般是对象区域，一般是空闲区域
  新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

  在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾会后器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

  完成复制后，对象区域与空闲区域继续”角色翻转“，也就是原来地对象区域变成空闲区域，原来地空闲区域变成了对象区域。这样就完成了垃圾对象地会后操作，同时这样”角色翻转地操作还能让新生代中地两块区域无线重复使用下去“
  
  当存活对象过多， 新生空间不够时， js会采用对象晋升策略（经过两次垃圾回收还存活的对象， 直接移动到老生区）

  # 主垃圾回收器
    负责对象：
      1. 新生区晋升地对象：存活时间长
      2. 一些大的对象会被直接分配到老生区：占用空间大

  - 标记-清除算法
    标记阶段: 递归遍历整个对象， 能到达的元素称“活对象”， 没有到达的元素可以判断为“死对象”

    增量标记发： 为了降低老生代的垃圾回收而造成的卡顿，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记个JavaScript应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为”增量标记算法“

 # 全停顿 
  因为JavaScript是运行在v8的主线程上的， 而垃圾回收的算法也算主线程， 那么就会出现当需要垃圾回收时，
  js的运行会暂停，等到垃圾回收完毕后再恢复运行 --- 全停顿

  全停顿再新生区是没有太大的影响， v8将标记过程分成一个个子标记过程, 同时让垃圾回收标记和js应用逻辑交替进行， 
  直到标记完成（增量标记法）
